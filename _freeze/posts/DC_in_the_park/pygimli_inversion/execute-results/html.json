{
  "hash": "ab6fe994332e3f2f08230e99d5267bb4",
  "result": {
    "markdown": "---\ntitle: \"Geophysical inversion\"\nauthor: \"Ralph-Uwe Börner\"\ndate: \"2022-11-24\"\ncategories: [code, python, geophysics]\n---\n\n# Inversion of DC resistivity data with `pyGIMLi`\n\nThe aim of the inversion is to reconstruct the spatial distribution of resistivity in the subsurface. This is based on the measured data, usually ohmic resistances $R(L)$ in $\\Omega$ or apparent resistivities $\\rho_s(L)$ in $\\Omega\\cdot m$. All measured values depend on the location and the geoelectric electrode configuration (denoted here by $L$).\n\n### Installation\n\nThe `pyGIMLi` is a Python library. We assume that a Python environment is already installed. The easiest option is [*anaconda*](https://www.anaconda.com/products/individual).\n\nFirst, `pyGIMLi` must be installed so that it can be accessed under Python. This is done with `conda`:\n\n``` shell\nconda install -c gimli -c conda-forge pygimli=1.3.0\n```\n\n### Preparation\n\nWe import the two libraries `pygimli` and `numpy`.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n%matplotlib inline\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport pygimli as pg\nimport numpy as np\nfrom pygimli.physics import ert\nfrom pygimli.physics.ert import ERTManager\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(pg.__version__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.2.6\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\n# The data format\n\n`pyGIMLi` expects the measured data in a special file format, the *Unified Data Format* [(description on the project page of BERT)](https://gitlab.com/resistivity-net/bert#the-unified-data-format). These are ASCII files, which can be edited with all common text editors.\n\nSuch a measured value file contains the following sections: - Number of electrodes as well as coordinates (position and height) of the electrodes with implicit numbering - Number of measured values as well as the data resulting in each case from the combination of two to four electrodes.\n\nThe example shows a small data set with 6 electrodes and 6 single measurements in the configuration *Dipole-Dipole* (recognizable by the order *a b m n* of the electrodes and probes). The 5th column of the data block contains the apparent resistivity (`rhoa`) in $\\Omega\\cdot m$.\n\n``` text\n6# Number of electrodes\n# x z position for each electrode\n0     0\n1     0\n2     0 # loose ground\n3     0\n4     0\n5     0\n6# Number of data\n# a b m n rhoa\n1   2   3   4  231.2\n2   3   4   5  256.7\n3   4   5   6  312.8 \n1   2   4   5  12.1 # possibly an outlier\n2   3   5   6  199.7\n1   2   5   6  246.2\n```\n\n## Inversion of a field data set\n\n### Background\n\nFor this example, we use data from a measurement above the piped stream \"Goldbach\" in the center of Freiberg.\n\nThe Goldbach, also known as the Saubach, is an approximately 5 km long left tributary of the Münzbach in Freiberg.\n\nIts entire course is located in the territory of the city of Freiberg. The headwaters are located between the Großer Teich and the Mittelteich ponds or around these ponds in the Freiberg city forest at an altitude of about 460 meters. After passing the Mittelteich, it flows about 300 m to the northwest and then turns almost 90° to the northeast. Parallel to the Ölmühlenweg it reaches the development boundary of the city of Freiberg. Here, at the level of the Schützenhaus on Chemnitzer Straße, it enters a piped section about 400 m long, which ends at the Mühlteich. After flowing through the Mühlteich, after about 200 m it reaches the Hammerteich with the former Freibergsdorfer Hammerwerk, to which it supplied the service water at that time. After another 800 m it is again piped. After flowing through the Kreuzteiche and the Schlüsselteich, it reaches the Münzbach in the Freiberg district of Loßnitz after about 5 km in a piped condition, having meanwhile turned to a more northerly direction.\n\n### DC resistivity profile setup\n\nThe profile measurement was carried out with the *Wenner*, and *Dipole-Dipole* configurations using 21 electrodes.\n\nThe dipole-dipole data set consists of 80 individual measurements, and the Wenner data set consists of 63 individual measurements. All data is stored in the file `parkall.mea`.\n\nThe Python object `wenner` contains all measured data:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nwenner = pg.load(\"parkall.mea\")\nprint(wenner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData: Sensors: 21 data: 143, nonzero entries: ['a', 'b', 'm', 'n', 'rhoa', 'valid']\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nwenner['k'] = ert.createGeometricFactors(wenner, numerical=True)\n```\n:::\n\n\nIn the `pyGIMLi` method `ERTManager()` all functions for the inversion of geoelectric data (*Electrical Resistivity Tomography*, ERT) are implemented.\n\nThe object `ertwenner` will hold, among others, the model response and the model parameters.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nertwenner = ERTManager()\n```\n:::\n\n\nSince our data set does not contain measurement errors, we estimate plausible absolute and relative data errors. Absolute errors are given in $\\Omega\\cdot m$.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nwenner['err'] = ertwenner.estimateError(wenner, absoluteError=0.1, relativeError=0.03)\n```\n:::\n\n\nThe following figure shows *pseudosections* of the **apparent resistivity** $\\rho_s$. The trapezoidal shape comes from the arbitrary choice of the horizontal reference point in the profile plot for the Wenner or dipole-dipole arrangement. The ordinates in the following two figures represent the electrode spacing for Wenner (WE) and the separation between current pole and voltage dipoles for the dipole-dipole (DD) array. **Note: The vertical axis is not a depth axis!**\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nertwenner.showData(wenner, cMap=\"RdBu_r\");\n```\n\n::: {.cell-output .cell-output-display}\n![](pygimli_inversion_files/figure-html/cell-9-output-1.png){width=596 height=431}\n:::\n:::\n\n\n### Data inversion\n\nThe method `ert.invert` performs the inversion of the data (`data`) for a specified regularization parameter $\\lambda$ (`lam=10`) and a maximum model depth of `paraDepth=10` meters and a maximum triangular size of the finite elements of `paraMaxCellSize=1` $m^2$.\n\nThe results of the inversion calculation -- the distribution of resistivity in the subsurface and the model response -- are stored in the object `mod`.\n\nThe `lam` parameter is assigned the value of the selected *regularization parameter* $\\lambda$.\n\nIf the value of $\\lambda$ is too low, a singularity of the least squares problem, if present, is expressed by strongly fluctuating values in the resistivity distribution in the subsurface. In the opposite case, if $\\lambda$ is too large, the resistivity distribution becomes very smooth.\n\nHere we can try out what influence the regularization parameter has on the solution of our problem.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nlam = 10\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nmodwenner = ertwenner.invert(wenner, lam=lam, paraMaxCellSize=0.1, paraDepth=6, verbose=False);\n```\n:::\n\n\nThe following figures illustrate the relationship between the model parameters ($\\rho(\\mathbf r)$) and the measured apparent resistivity (`Data`) and the model response (`Response`).\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nertwenner.showResultAndFit(cMap=\"RdBu_r\");\n```\n\n::: {.cell-output .cell-output-display}\n![](pygimli_inversion_files/figure-html/cell-12-output-1.png){width=659 height=469}\n:::\n:::\n\n\nThe Goldbach flows in a concrete pipe at about profile meter 12.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nertwenner.showModel(modwenner, cMap=\"RdBu_r\");\n```\n\n::: {.cell-output .cell-output-display}\n![](pygimli_inversion_files/figure-html/cell-13-output-1.png){width=586 height=264}\n:::\n:::\n\n\nOf interest is the goodness of fit, which we refer to as *misfit*. This is the relative error between data and model response. A graphical representation of this error is informative:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nmisfitwe = ertwenner.inv.response / wenner['rhoa'] * 100 - 100\nme = np.max(np.abs(misfitwe))\npg.show(wenner, misfitwe, cMap=\"RdBu_r\", cMin=-me, cMax=me, label=\"misfit (%)\");\n```\n\n::: {.cell-output .cell-output-display}\n![](pygimli_inversion_files/figure-html/cell-14-output-1.png){width=599 height=429}\n:::\n:::\n\n\nThe global misfit is described with the $\\chi^2$-statistic and amounts to\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nertwenner.inv.chi2()\n```\n\n::: {.cell-output .cell-output-display execution_count=172}\n```\n0.8469349648613855\n```\n:::\n:::\n\n\n## Discussion\n\nWe have seen that the inversion result can be influenced by the choice of different parameters. Especially the data fitting and model properties are affected.\n\n-   Which parameter controls the roughness of the model?\n\n",
    "supporting": [
      "pygimli_inversion_files"
    ],
    "filters": [],
    "includes": {}
  }
}