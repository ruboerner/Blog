{
  "hash": "c5be129d210f0bab87f371ae0432bfa4",
  "result": {
    "markdown": "---\ntitle: Geodetic coordinate transforms with Julia\nauthor: Ralph-Uwe BÃ¶rner\ndate: '2022-10-26'\ncategories:\n  - code\n  - julia\n---\n\nThis blog post is about geodetic coordinate transforms using the `Julia` programming language.\n\nIn applied geophysics, the following question comes up frequently:\n\n::: callout-important\n## Problem ðŸ’»\n\nHow can I transform geographical coordinates given as \"`latitude, longitude`\" into some other coordinate system, e.g., UTM?\n:::\n\nThe `Julia` package `Proj.jl` offers all functionality that is required.\n\nAfter installing the package using `Julia`'s package manager from the REPL, we are ready to go:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Proj\nusing DataFrames, CSV\n```\n:::\n\n\nLet's assume that we have downloaded a set of coordinates from a handheld GPS receiver. The content of the data file `coords.dat` may look like this:\n\n    # lat, lon\n    50.92483350345329, 13.33056291517176\n\nWe first read in the data:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ndf = DataFrame(CSV.File(\"coords.dat\", delim=\",\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```{=html}\n<div class=\"data-frame\"><p>2 rows Ã— 2 columns</p><table class=\"data-frame\"><thead><tr><th></th><th># lat</th><th> lon</th></tr><tr><th></th><th title=\"Float64\">Float64</th><th title=\"Float64\">Float64</th></tr></thead><tbody><tr><th>1</th><td>50.9248</td><td>13.3306</td></tr><tr><th>2</th><td>50.9826</td><td>13.5304</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nNext we arrange the data such that it is suitable for processing with `Proj.jl`:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nlatlon = Array(df)\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\n2Ã—2 Matrix{Float64}:\n 50.9248  13.3306\n 50.9826  13.5304\n```\n:::\n:::\n\n\nThe following step is essential. Since we transform data from one coordinate system into another, we have to inform `Proj.jl` about the source and target systems. To this end, we exploit the convenient EPSG codes.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ntrans = Proj.Transformation(\"EPSG:4326\", \"EPSG:25833\")\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\nTransformation\n    source: WGS 84\n    target: ETRS89 / UTM zone 33N\n    direction: forward\n```\n:::\n:::\n\n\nThe next lines will finally transform our GPS coordinates into UTM zone 33 coordinates which we refer to as _easting_ and _northing_:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\netrs = [trans(latlon[i, :]) for i in 1:size(latlon, 1)]\nUTM = hcat(collect.(etrs)...);\n\neasting = UTM[1, :]\nnorthing = UTM[2, :]\n@show easting\n@show northing;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neasting = [382670.4901574054, 396843.0546304857]\nnorthing = [5.64279329582307e6, 5.648923257065746e6]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}